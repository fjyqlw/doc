# 计算一个正整数的二进制有几个1

二进制遍历的时间复杂度是O(n)，下面介绍一种更高效的位移算法，其计算步骤是：如果一个正整数x与x-1做按位与运算的结果>0，那么就说明这个正整数x的二进制里面包含了一个1，因此可以循环计算，直到x<=0，执行计算的次数就是1的个数。

- 举个例子：11的二进制是：00001011，11-1=10的二进制：00001010，11&10=00001010=10，此时计算了1次；10(00001010)&9(00001001)=8(00001000)，此时计算了2次，8(00001000)&7(00000111)=0，此时计算了3次。因此11的二进制里有3个1。发现规律了么，11与10做与操作，正好能抵消一个二进制的1，因为二进制的进位是2，因此一位上面要么是0，要么是1，如果是1+1那么该位就变为0且向前一位进1；反过来，11的二进制是00001011,11-1的二进制是00001010，做与操作，正好把最低位（最右边）第一个1抵消了，依次类推，运算几次就有几个1。

- 原理：x与x-1做按位&操作，将右侧向左第一个二进制的1抵消，因此运算了几次，x的二进制表示就有几个1。

- 时间复杂度：可以看到，该算法的运算次数只跟x中包含了几个1有关，如果x中包含了10个1，那么算法就运算了10次，最坏情况下，例如2^n-1二进制表示全是1，时间复杂度为O(n)。

## 实现
```java
public class HasOne {
    public static void main(String[] args) {
        int num = 7;

        int count = 0;
        while (num > 0) {
            num =num&(num-1);
            count ++;
        }

        System.out.println(count);
    }
}
```